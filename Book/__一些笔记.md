- 目前客户端共有5个程序集，其作用如下 

  - 1.Model 逻辑层数据结构定义 
  
  - 2.Hotfix 逻辑层的逻辑方法 
  
  - 3.ModelView 显示层的数据结构定义 
  
  - 4.HotfixView 显示层的逻辑方法 
  
  - 5.ThirdParty 第三方库 

  ```(这四个程序集引用Mono工程，dll引用Unity/Temp/Bin/Debug下的dll)```

<br/><br/>

- 为什么要分出ModelView跟HotfixView呢？
  
    主要原因是要分离显示层跟逻辑层，逻辑层的代码其实可以用来做压测机器人。
  如果一开始就定好这样的结构，压测机器人完全可以利用客户端逻辑层的代码，节省大量时间

<br/><br/>

- Unity.Mono工程，用来放置Unity脚本代码。作为热更新的冷更层。 
    
    Model ModelView Hotfix HotfixView 不允许放任何MonoBehaviour脚本

<br/><br/>

- 机器人Console创建命令: CreateRobot --Num=10

<br/><br/>

-------------------------------------------


- EventSystem.cs下的PublishAsync方法需要留意，出个代码段排坑记录一下
```csharp {.line-numbers}
// 如果是你如下这种异步方式抛事件
await Game.EventSystem.PublishAsync(new EventType.AppStartInitFinish() { ZoneScene = zoneScene });

// 那么事件处理类一定要继承AEventAsync而不是下面代码段的AEvent
public class AppStartInitFinish_CreateLoginUI: AEvent<EventType.AppStartInitFinish>
{
    ...
}

// 原因附上EventSystem下的代码段和注释，不过ET7.2里已经统一成了AEvent，确实TM有点坑
public async ETTask PublishAsync<T>(T a) where T : struct
{
    List<object> iEvents;
    if (!this.allEvents.TryGetValue(typeof(T), out iEvents))
    {
        return;
    }

    using (ListComponent<ETTask> list = ListComponent<ETTask>.Create())
    {
        for (int i = 0; i < iEvents.Count; ++i)
        {
            object obj = iEvents[i];
            if (!(obj is AEventAsync<T> aEvent)) //看这里！！！
            {
                Log.Error($"event error: {obj.GetType().FullName}");
                continue;
            }

            list.Add(aEvent.Handle(a));
        }

        try
        {
            await ETTaskHelper.WaitAll(list);
        }
        catch (Exception e)
        {
            Log.Error(e);
        }
    }
}
```